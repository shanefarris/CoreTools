// Class for reading a real file from disk, implements IReadFile
// Updated 5-8-07
namespace IO
{
	class  CAsynReadFile : public IReadFile
	{
public:
		CAsynReadFile(const char* Filename);
		~CAsynReadFile();
		int Read(void* Buffer);
		int Read(void* Buffer, int ReadSize);
		bool  Seek(int FinalPos, bool RelativeMovement = false);
		inline unsigned int  GetSize() { return FileSize; }
		inline int GetPos() { return ReaderPos; }
		inline int GetNumBlocks() { return NumBlocks; }
		inline int GetNumBlocksMask() { return NumBlocksMask; }
		inline int GetBlockSize() { return BlockSize; }
		inline const char* GetFileName() { return FileName.c_str(); }
		inline bool IsOpen() { return m_File != 0; }
	};
} // End namespace IO
namespace IO
{
	class  CConfig 
	{
	public:
		CConfig(CFileSystem* FileSystem);
		bool ReadConfig(String &FileName);
		String GetValue(String Entry) const;
};
}
namespace Core
{
namespace Debug
{
	// Enum used to describe debug levels used in logging debugging information
	enum DEBUG_LEVEL
	{
		NONE		= 0,	// Used to set the specific object not do log any info messages 
		INFO_BASIC	= 1,	// This is for messages that happens rarely e.g. initializing, shutdown messages 
		INFO_EVENT	= 2,	// For messages that happens prety often but not "all the time" e.g. events 
		INFO_HEAVY	= 3		// This is for the rely frequent messages e.g "every frame information" 
	};
	// class used by the Debuger to store managedLogs
	class ManagedLogElement
	{
	public:
		ManagedLogElement(const std::string *fileName, const std::string *text) { file = *fileName; textBuffer = *text;}
		~ManagedLogElement() {}
		std::string file;
		std::string textBuffer;
	};
	// A debug manager for creating and writing logs.
	/* 
	 *	Note: Writing to a file is not a very fast operation, so it might couse a small lag and shuld only be used for debuging.
	 *	The ManagedLogAdd dosent write the data emitetly it saves the data and writes it on program shutdown or on a call to ManagedLogEnd. 
	 */
	class  CDebugManager
	{
	public:
		~CDebugManager();
		
		static CDebugManager* Instance();
		void AddWarning(const char* formatText, ...);		// Adds a warning using a printf style formated text.
		void AddError(const char* formatText, ...);			// Adds a error using a printf style formated text.
		void AddLog(const char* formatText, ...);			// Adds a log using a printf style formated text.
		
		void ManagedLogAdd(const char* fileName, const char* formatText, ...);	// Adds a managed Log message using a printf style formated text.
		void ManagedLogEnd(const char* fileName);			// This function writes a text buffer to a file and delets the buffer.
		void ManagedLogEndAll();							// Function that wites all managed logs, cald at shutdown.
		const char* GetDate();								// Retreves the system date as a string
		const char* GetTime();								// Retreves the system time as a string
};
}
}
//FileSystem, which manages where files are, so that modules which use the io do not need to know where every file is located.
// Updated 5-1-07
namespace IO
{
	class  CFileList : public IFileList
	{
};
		String Path;
		std::vector<FileEntry> Files;
	public:
		CFileList();
		 ~CFileList() { }
		 unsigned int GetFileCount();
		 const char* GetFileName(int Index);
		 const char* GetFullFileName(int Index);
		 bool IsDirectory(int Index);
	};
} // End namespace IO
// FileSystem which uses normal files and one zipfile.
// Original 5-1-07, Updated 5-30-7 (GetFileExtension)
//#include "CAttributes.h"
namespace IO
{
	class CZipReader;
	class CPakReader;
	class CUnZipReader;
	const int FILE_SYSTEM_MAX_PATH = 1024;
	class  CFileSystem : public IFileSystem
	{
public:
		CFileSystem();
		~CFileSystem();
		IReadFile*		CreateAndOpenFile(const char* FileName);
		IWriteFile*		CreateAndWriteFile(const char* FileName, bool append = false, bool isBinary = true);
		bool			AddZipFileArchive(const char* FileName, bool IgnoreCase = true, bool IgnorePaths = true);
		bool			AddFolderFileArchive(const char* FileName, bool IgnoreCase = true, bool IgnorePaths = true);
		bool			AddUnZipFileArchive(const char* FileName, bool IgnoreCase = true, bool IgnorePaths = true);
		bool			AddPakFileArchive(const char* FileName, bool IgnoreCase = true, bool IgnorePaths = true);
		const char*		GetWorkingDirectory();
		bool			ChangeWorkingDirectoryTo(const char* newDirectory);
		String			GetAbsolutePath(String& FileName);
		String			GetFileDir(String &FileName);
		IFileList*		CreateFileList();
		IXMLReader*		CreateXMLReader(const char* FileName);
		IXMLReader*		CreateXMLReader(IReadFile* File);
		IXMLReaderUTF8* CreateXMLReaderUTF8(const char* FileName);
		IXMLReaderUTF8* CreateXMLReaderUTF8(IReadFile* File);
		IXMLWriter*		CreateXMLWriter(const char* FileName);
		IXMLWriter*		CreateXMLWriter(IWriteFile* File);
		bool			ExistFile(const char* FileName);				// File exist in loaded files
		static bool		IsFileExist(const char* FileName);				// Does the file exist on the computer
		static String   GetFileExtension(const String& FileName);
	};
}
/* This is a Read file, which is limited to some boundaries, so that it may only Start from a certain file position and may only Read until a certain 
 * file position. This can be useful, for example for reading uncompressed files in an archive(zip).
 * Updated 5-3-07
 */
namespace IO
{
	class CUnicodeConverter;
	class  CLimitReadFile : public IReadFile
	{
public:
		CLimitReadFile(IReadFile* File, int Size, const char* Name);
		 ~CLimitReadFile();
		 int Read(void* Buffer);
		 int Read(void* Buffer, int SizeToRead);
		 bool Seek(int FinalPos, bool RelativeMovement = false);
		 unsigned int GetSize()				{ return AreaSize; };
		 int GetPos()				{ return m_File->GetPos() - AreaStart; }
		 const char* GetFileName()	{ return Filename.c_str(); }
	
	};
} // End namespace IO
// Class for reading from Memory.
// Updated 5-7-07
namespace IO
{
	class  CMemoryReadFile : public IReadFile
	{
public:
		CMemoryReadFile(void* Memory, int Length, const char* Filename, bool DeleteMemoryWhenDropped);
		 ~CMemoryReadFile();
		 int Read(void* Buffer);
		 int Read(void* Buffer, int SizeToRead);
		 bool Seek(int FinalPos, bool RelativeMovement = false);
		 unsigned int GetSize()			  { return Len; }
		 int GetPos()			  { return Pos; }
		 const char* GetFileName() { return FileName.c_str(); }
	
	};
} // End namespace IO
//#include "CAttributes.h"
namespace IO
{
	class CFileSystem;
	class  COgreFileSystem : public IFileSystem
	{
public:
		COgreFileSystem();
		~COgreFileSystem();
		IReadFile*		CreateAndOpenFile(const char* FileName);
		IWriteFile*		CreateAndWriteFile(const char* FileName, bool append = false, bool isBinary = true);
		bool			AddZipFileArchive(const char* FileName, bool IgnoreCase = true, bool IgnorePaths = true);
		bool			AddFolderFileArchive(const char* FileName, bool IgnoreCase = true, bool IgnorePaths = true);
		bool			AddUnZipFileArchive(const char* FileName, bool IgnoreCase = true, bool IgnorePaths = true);
		bool			AddPakFileArchive(const char* FileName, bool IgnoreCase = true, bool IgnorePaths = true);
		const char*		GetWorkingDirectory();
		bool			ChangeWorkingDirectoryTo(const char* newDirectory);
		String			GetAbsolutePath(String& FileName);
		String			GetFileDir(String &FileName);
		IFileList*		CreateFileList();
		IXMLReader*		CreateXMLReader(const char* FileName);
		IXMLReader*		CreateXMLReader(IReadFile* File);
		IXMLReaderUTF8* CreateXMLReaderUTF8(const char* FileName);
		IXMLReaderUTF8* CreateXMLReaderUTF8(IReadFile* File);
		IXMLWriter*		CreateXMLWriter(const char* FileName);
		IXMLWriter*		CreateXMLWriter(IWriteFile* File);
		bool			ExistFile(const char* FileName);				// File exist in loaded files
		static bool		IsFileExist(const char* FileName);				// Does the file exist on the computer
		static String   GetFileExtension(const String& FileName);
	};
}
// Archived files
// Updated 5-8-07
namespace IO
{
	struct SPAKFileHeader
	{
		char tag[4];
		unsigned int offset;
		unsigned int Length;
	};
	struct SPakFileEntry
	{
		String PakFileName;
		String SimpleFileName;
		String Path;
		unsigned int	Position;
		unsigned int	Length;
		bool operator <(const SPakFileEntry& Other) const { return SimpleFileName < Other.SimpleFileName; }
		bool operator ==(const SPakFileEntry& Other) const { return SimpleFileName == Other.SimpleFileName; }
	};
	class  CPakReader
	{
public:
		CPakReader(IReadFile* File, bool ignoreCase, bool ignorePaths);
		 ~CPakReader();
		 IReadFile* OpenFile(const char* Filename);			// Opens a File by File name
		IReadFile* OpenFile(int Index);								// Opens a File by Index
		size_t GetFileCount() { return FileList.size(); }			// Returns count of files in archive
		const SPakFileEntry* GetFileInfo(int Index) const;			// Returns data of File
		int FindFile(const char* Filename);							// Returns fileindex
	
	};
} // End namespace IO
// Class for reading a real file from disk, implements IReadFile
// Updated 5-8-07
namespace IO
{
	class  CReadFile : public IReadFile
	{
public:
		CReadFile(const char* Filename);
		 ~CReadFile();
		 int Read(void* Buffer);
		 int Read(void* Buffer, int ReadSize);
		 bool Seek(int FinalPos, bool RelativeMovement = false);
		 unsigned int GetSize()			  { return FileSize; }
		 int GetPos()			  { return ftell(m_File); }
		 const char* GetFileName() { return FileName.c_str(); }
		inline bool IsOpen()			  { return m_File != nullptr; }
	};
} // End namespace IO
// Class for writing a real file to disk, implements IWriteFile
// Updated 5-8-07
namespace IO
{
	class  CWriteFile : public IWriteFile
	{
public:
		CWriteFile(const char* Filename, bool append, bool isBinary = true);
		 ~CWriteFile();
		 unsigned int Write(const void* Buffer, unsigned int WriteSize);
		 bool Seek(int FinalPos, bool RelativeMovement = false);
		 int GetPos()				{ return ftell(m_File); }
		 const char* GetFileName()	{ return Filename.c_str(); }
		inline bool IsOpen()				{ return m_File != nullptr; }
	};
} // End namespace IO
// Front end methods for XML reader
// Updated 5-8-07
namespace IO
{
	class IReadFile;
	IXMLReader* CreateIXMLReader(IReadFile* File);
	IXMLReaderUTF8* CreateIXMLReaderUTF8(IReadFile* File);
}  
namespace IO
{
// Implementation of the XMLReader8
template<class CharType> class  CXMLReaderImpl : public IEngineXMLReader<CharType>
{
public:
	CXMLReaderImpl(IFileReadCallBack* callback, bool deleteCallBack = true)
		: TextData(0), P(0), TextSize(0), TextBegin(0), CurrentNodeType(XML_NODE_NONE),
		SourceFormat(XML_TEXT_ASCII), TargetFormat(XML_TEXT_ASCII)
	{
		if(!callback)
			return;
		storeTargetFormat();
		// Read whole xml file
		readFile(callback);
		
		// Clean up
		if(deleteCallBack)
			DELETE(callback);
		// create list with special characters
		createSpecialCharacterList();
		// set pointer to text Begin
		P = TextBegin;
	}
    	
	 ~CXMLReaderImpl()
	{
		delete [] TextData;
	}
	// Reads forward to the next xml node.  
	 bool Read()
	{
		// if not End reached, parse the node
		if(P &&(unsigned int)(P - TextBegin) < TextSize - 1 && *P != 0)
		{
			parseCurrentNode();
			return true;
		}
		return false;
	}
	// Returns the type of the current XML node.
	 XML_NODE_TYPE GetNodeType() const
	{
		return CurrentNodeType;
	}
	// Returns attribute count of the current XML node.
	 unsigned int GetAttributeCount() const
	{
		return (unsigned int)Attributes.size();
	}
	// Returns name of an attribute.
	 const CharType* GetAttributeName(unsigned int idx) const
	{
		if(idx < 0 || idx >=(unsigned int)Attributes.size())
			return nullptr;
		return (CharType*)Attributes[idx].Name.c_str();
	}
	// Returns the value of an attribute. 
	 const CharType* GetAttributeValue(unsigned int idx) const
	{
		if(idx < 0 || idx >=(unsigned int)Attributes.size())
			return nullptr;
		return (CharType*)Attributes[idx].Value.c_str();
	}
	// Returns the value of an attribute. 
	 const CharType* GetAttributeValue(const CharType* name) const
	{
		const SAttribute* attr = getAttributeByName(name);
		if(!attr)
			return nullptr;
		return (CharType*)attr->Value.c_str();
	}
	// Returns the value of an attribute
	 const CharType* GetAttributeValueSafe(const CharType* name) const
	{
		const SAttribute* attr = getAttributeByName(name);
		if(!attr)
			return (CharType*)EmptyString.c_str();
		return (CharType*)attr->Value.c_str();
	}
	// Returns the value of an attribute as integer. 
	int GetAttributeValueAsInt(const CharType* name) const
	{
		return(int)GetAttributeValueAsFloat(name);
	}
	// Returns the value of an attribute as integer. 
	int GetAttributeValueAsInt(unsigned int idx) const
	{
		return(int)GetAttributeValueAsFloat(idx);
	}
	// Returns the value of an attribute as float. 
	float GetAttributeValueAsFloat(const CharType* name) const
	{
		const SAttribute* attr = getAttributeByName(name);
		if(!attr)
			return 0;
		String c = attr->Value.c_str();
		return fast_atof(c.c_str());
	}
	// Returns the value of an attribute as float. 
	float GetAttributeValueAsFloat(unsigned int idx) const
	{
		const CharType* attrvalue = GetAttributeValue(idx);
		if(!attrvalue)
			return 0;
		String c(attrvalue);
		return fast_atof(c.c_str());
	}
	// Returns the name of the current node.
	 const CharType* GetNodeName() const
	{
		return NodeName.c_str();
	}
	// Returns data of the current node.
	 const CharType* GetNodeData() const
	{
		return NodeName.c_str();
	}
	// Returns if an Element is an empty Element, like <foo />
	 bool IsEmptyElement() const
	{
		return isEmptyElement;
	}
	// Returns format of the source xml file.
	 XML_TEXT_FORMAT_TYPE GetSourceFormat() const
	{
		return SourceFormat;
	}
	// Returns format of the strings returned by the parser.
	 XML_TEXT_FORMAT_TYPE GetParserFormat() const
	{
		return TargetFormat;
	}
};
	// sets the state that text was found. Returns true if set should be set
	bool SetText(CharType* Start, CharType* End)
	{
		// check if text is more than 2 characters, and if not, check if there is 
		// only white space, so that this text won't be reported
		if(End - Start < 3)
		{
			CharType* p = Start;
			for(; p != End; ++p)
				if(!isWhiteSpace(*p))
					break;
			if(p == End)
				return false;
		}
		// set current text to the parsed text, and replace xml special characters
		String s(Start,(int)(End - Start));
		NodeName = replaceSpecialCharacters(s);
		// current XML node type is text
		CurrentNodeType = XML_NODE_TEXT;
		return true;
	}
	// ignores an xml definition like <?xml something />
	void ignoreDefinition()
	{
		CurrentNodeType = XML_NODE_UNKNOWN;
		// move until End marked with '>' reached
		while(*P != L'>')
			++P;
		++P;
	}
	// parses a comment
	void parseComment()
	{
		CurrentNodeType = XML_NODE_COMMENT;
		P += 1;
		CharType *pCommentBegin = P;
		int count = 1;
		// move until End of comment reached
		while(count)
		{
			if(*P == L'>')
				--count;
			else
			if(*P == L'<')
				++count;
			++P;
		}
		P -= 3;
		NodeName = String(pCommentBegin+2,(int)(P - pCommentBegin-2));
		P += 3;
	}
	// parses an opening xml Element and reads attributes
	void parseOpeningXMLElement()
	{
		CurrentNodeType = XML_NODE_ELEMENT;
		isEmptyElement = false;
		Attributes.clear();
		// find name
		const CharType* startName = P;
		// find End of Element
		while(*P != L'>' && !isWhiteSpace(*P))
			++P;
		const CharType* endName = P;
		// find Attributes
		while(*P != L'>')
		{
			if(isWhiteSpace(*P))
				++P;
			else
			{
				if(*P != L'/')
				{
					// we've got an attribute
					// Read the attribute names
					const CharType* AttributeNameBegin = P;
					while(!isWhiteSpace(*P) && *P != L'=')
						++P;
					const CharType* AttributeNameEnd = P;
					++P;
					// Read the attribute value
					// check for quotes and single quotes, thx to murphy
					while((*P != L'\"') &&(*P != L'\'') && *P) 
						++P;
					if(!*P) // malformatted xml file
						return;
					const CharType attributeQuoteChar = *P;
					++P;
					const CharType* attributeValueBegin = P;
					
					while(*P != attributeQuoteChar && *P)
						++P;
					if(!*P) // malformatted xml file
						return;
					const CharType* attributeValueEnd = P;
					++P;
					SAttribute attr;
					attr.Name = String(AttributeNameBegin, 
						(int)(AttributeNameEnd - AttributeNameBegin));
					String s(attributeValueBegin, 
						(int)(attributeValueEnd - attributeValueBegin));
					attr.Value = replaceSpecialCharacters(s);
					Attributes.push_back(attr);
				}
				else
				{
					// tag is closed directly
					++P;
					isEmptyElement = true;
					break;
				}
			}
		}
		// check if this tag is closing directly
		if(endName > startName && *(endName-1) == L'/')
		{
			// directly closing tag
			isEmptyElement = true;
			endName--;
		}
		
		NodeName = String(startName,(int)(endName - startName));
		++P;
	}
	// parses an closing xml tag
	void parseClosingXMLElement()
	{
		CurrentNodeType = XML_NODE_ELEMENT_END;
		isEmptyElement = false;
		Attributes.clear();
		++P;
		const CharType* pBeginClose = P;
		while(*P != L'>')
			++P;
		NodeName = String(pBeginClose,(int)(P - pBeginClose));
		++P;
	}
	// parses a possible CDATA section, returns false if Begin was not a CDATA section
	bool parseCDATA()
	{
		if(*(P+1) != L'[')
			return false;
		CurrentNodeType = XML_NODE_CDATA;
		// skip '<![CDATA['
		int count=0;
		while(*P && count<8)
		{
			++P;
			++count;
		}
		if(!*P)
			return true;
		CharType *cDataBegin = P;
		CharType *cDataEnd = nullptr;
		// find End of CDATA
		while(*P && !cDataEnd)
		{
			if(*P == L'>' && 
			  (*(P-1) == L']') &&
			  (*(P-2) == L']'))
			{
				cDataEnd = P - 2;
			}
			++P;
		}
		if(cDataEnd)
			NodeName = String(cDataBegin,(int)(cDataEnd - cDataBegin));
		else
			NodeName = "";
		return true;
	}
	// structure for storing attribute-name pairs
	struct SAttribute
	{
		String Name;
		String Value;
	};
	// finds a current attribute by name, returns 0 if not found
	const SAttribute* getAttributeByName(const CharType* name) const
	{
		if(!name)
			return nullptr;
		String n = name;
		for(int i=0; i<(int)Attributes.size(); ++i)
			if(Attributes[i].Name == n)
				return &Attributes[i];
		return nullptr;
	}
	// replaces xml special characters in a string and creates a new one
	String replaceSpecialCharacters(String& origstr)
	{
		unsigned int pos = origstr.find_first_of(L'&');
		unsigned int oldPos = 0;
		if(pos == String::npos)
			return origstr;
		String newstr;
		while(pos != -1 && pos < origstr.size() - 2)
		{
			// check if it is one of the special characters
			int specialChar = -1;
			for(int i=0; i<(int)SpecialCharacters.size(); ++i)
			{
				const CharType* p = &origstr.c_str()[pos]+1;
				if(EqualsN(&SpecialCharacters[i][1], p, SpecialCharacters[i].size()-1))
				{
					specialChar = i;
					break;
				}
			}
			if(specialChar != -1)
			{
				newstr.append(origstr.substr(oldPos, pos - oldPos));
				newstr.append(SpecialCharacters[specialChar].c_str());
				pos += SpecialCharacters[specialChar].size();
			}
			else
			{
				newstr.append(origstr.substr(oldPos, pos - oldPos + 1));
				pos += 1;
			}
			// find next &
			oldPos = pos;
			pos = origstr.find(L'&', pos);		
		}
		if(oldPos < origstr.size()-1)
			newstr.append(origstr.substr(oldPos, origstr.size()-oldPos));
		return newstr;
	}
	// reads the xml file and converts it into the wanted character format.
	bool readFile(IFileReadCallBack* callback)
	{
		int Size = callback->GetSize();		
		Size += 4; // We need two terminating 0's at the End.
		           // For ASCII we need 1 0's, for UTF-16 2, for UTF-32 4.
		char* data8 = new char[Size];
		if(!callback->Read(data8, Size-4))
		{
			delete [] data8;
			return false;
		}
		// add zeros at End
		data8[Size-1] = 0;
		data8[Size-2] = 0;
		data8[Size-3] = 0;
		data8[Size-4] = 0;
		s16* data16 = reinterpret_cast<s16*>(data8);
		unsigned int* data32 = reinterpret_cast<unsigned int*>(data8);	
		// now we need to convert the data to the desired target format
		// based on the byte order mark.
		const unsigned char UTF8[] = {0xEF, 0xBB, 0xBF}; // 0xEFBBBF;
		const int UTF16_BE = 0xFFFE;
		const int UTF16_LE = 0xFEFF;
		const int UTF32_BE = 0xFFFE0000;
		const int UTF32_LE = 0x0000FEFF;
		// check source for all utf versions and convert to target data format
		if(Size >= 4 && data32[0] ==(unsigned int)UTF32_BE)
		{
			// UTF-32, big endian
			SourceFormat = XML_TEXT_UTF32_BE;
			convertTextData(data32+1, data8,(Size/4)); // data32+1 because we need to skip the header
		}
		else if(Size >= 4 && data32[0] ==(unsigned int)UTF32_LE)
		{
			// UTF-32, little endian
			SourceFormat = XML_TEXT_UTF32_LE;
			convertTextData(data32+1, data8,(Size/4)); // data32+1 because we need to skip the header
		}
		else if(Size >= 2 && data16[0] == UTF16_BE)
		{
			// UTF-16, big endian
			SourceFormat = XML_TEXT_UTF16_BE;
			convertTextData(data16+1, data8,(Size/2)); // data16+1 because we need to skip the header
		}
		else if(Size >= 2 && data16[0] == UTF16_LE)
		{
			// UTF-16, little endian
			SourceFormat = XML_TEXT_UTF16_LE;
			convertTextData(data16+1, data8,(Size/2)); // data16+1 because we need to skip the header
		}
		else if(Size >= 3 && data8[0] == UTF8[0] && data8[1] == UTF8[1] && data8[2] == UTF8[2])
		{
			// UTF-8
			SourceFormat = XML_TEXT_UTF8;
			convertTextData(data8+3, data8, Size); // data8+3 because we need to skip the header
		}
		else
		{
			// ASCII
			SourceFormat = XML_TEXT_ASCII;
			convertTextData(data8, data8, Size);
		}
		return true;
	}
	// converts the text file into the desired format.
	template<class src_char_type> void convertTextData(src_char_type* source, char* pointerToStore, int sizeWithoutHeader)
	{
		// convert little to big endian if necessary
		if(sizeof(src_char_type) > 1 && 
			isLittleEndian(TargetFormat) != isLittleEndian(SourceFormat))
			convertToLittleEndian(source);
		// check if conversion is necessary:
		if(sizeof(src_char_type) == sizeof(CharType))
		{
			// no need to convert
			TextBegin =(CharType*)source;
			TextData =(CharType*)pointerToStore;
			TextSize = sizeWithoutHeader;
		}
		else
		{
			// convert source into target data format. 
			// TODO: implement a real conversion. This one just 
			// copies bytes. This is a problem when there are 
			// unicode symbols using more than one character.
			TextData = new CharType[sizeWithoutHeader];
			for(int i=0; i<sizeWithoutHeader; ++i)
				TextData[i] =(CharType)source[i];
			TextBegin = TextData;
			TextSize = sizeWithoutHeader;
			// delete original data because no longer needed
			delete [] pointerToStore;
		}
	}
	// converts whole text buffer to little endian
	template<class src_char_type> void convertToLittleEndian(src_char_type* t)
	{
		if(sizeof(src_char_type) == 4) 
		{
			// 32 bit
			while(*t)
			{
				*t =((*t & 0xff000000) >> 24) |
				    ((*t & 0x00ff0000) >> 8)  |
				    ((*t & 0x0000ff00) << 8)  |
				    ((*t & 0x000000ff) << 24);
				++t;
			}
		}
		else
		{
			// 16 bit 
			while(*t)
			{
				*t =(*t >> 8) |(*t << 8);
				++t;
			}
		}
	}
	// returns if a format is little endian
	inline bool isLittleEndian(XML_TEXT_FORMAT_TYPE f)
	{
		return f == XML_TEXT_ASCII ||
		       f == XML_TEXT_UTF8 ||
		       f == XML_TEXT_UTF16_LE ||
		       f == XML_TEXT_UTF32_LE;
	}
	// returns true if a character is whitespace
	inline bool isWhiteSpace(CharType c)
	{
		return(c==' ' || c=='\t' || c=='\n' || c=='\r');
	}
	// generates a list with xml special characters
	void createSpecialCharacterList()
	{
		// list of strings containing special symbols, 
		// the first character is the special character,
		// the following is the symbol string without trailing &.
		SpecialCharacters.push_back("&amp;");
		SpecialCharacters.push_back("<lt;");
		SpecialCharacters.push_back(">gt;");
		SpecialCharacters.push_back("\"quot;");
		SpecialCharacters.push_back("'apos;");
		
	}
	// compares the first n characters of the strings
	bool EqualsN(const CharType* str1, const CharType* str2, int len)
	{
		int i;
		for(i=0; str1[i] && str2[i] && i < len; ++i)
			if(str1[i] != str2[i])
				return false;
		// if one(or both) of the strings was smaller then they
		// are only equal if they have the same lenght
		return(i == len) ||(str1[i] == 0 && str2[i] == 0);
	}
	// stores the target text format
	void storeTargetFormat()
	{
		// get target format. We could have done this using template specialization,
		// but VisualStudio 6 don't like it and we want to support it.
		switch(sizeof(CharType))
		{
		case 1: 
			TargetFormat = XML_TEXT_UTF8;
			break;
		case 2: 
			TargetFormat = XML_TEXT_UTF16_LE;
			break;
		case 4: 
			TargetFormat = XML_TEXT_UTF32_LE;
			break;
		default:
			TargetFormat = XML_TEXT_ASCII; // should never happen.
		}
	}
	// instance variables:
	CharType* TextData;         // data block of the text file
	CharType* P;                // current point in text to parse
	CharType* TextBegin;        // Start of text to parse
	unsigned int TextSize;				// Size of text to parse in characters, not bytes
	XML_NODE_TYPE CurrentNodeType;   // type of the currently parsed node
	XML_TEXT_FORMAT_TYPE SourceFormat;   // source format of the xml file
	XML_TEXT_FORMAT_TYPE TargetFormat;   // output format of this parser
	String NodeName;    // name of the node currently in
	String EmptyString; // empty string to be returned by getSafe() methods
	bool isEmptyElement;       // is the currently parsed node empty?
	std::vector< String > SpecialCharacters; // see createSpecialCharacterList()
	std::vector<SAttribute> Attributes; // attributes of current Element
	
}; // End CXMLReaderImpl
} // End namespace
// Interface providing methods for making it easier to write XML files.
// Updated 5-8-07
namespace IO
{
	class  CXMLWriter : public IXMLWriter
	{
public:
		CXMLWriter(IWriteFile* File);
		 ~CXMLWriter();
		 void WriteXMLHeader();
		 void WriteElement(const char* Name, bool Empty = false,
			const char* Attribute1Name = 0, const char* Attribute1Value = 0,
			const char* Attribute2Name = 0, const char* Attribute2Value = 0,
			const char* Attribute3Name = 0, const char* Attribute3Value = 0,
			const char* Attribute4Name = 0, const char* Attribute4Value = 0,
			const char* Attribute5Name = 0, const char* Attribute5Value = 0);
		 void WriteElement(const char* Name, bool Empty, std::vector<String> &Names, std::vector<String> &Values);
		 void WriteComment(const char* Comment);
		 void WriteClosingTag(const char* Name);
		 void WriteText(const char* Text);
		 void WriteLineBreak();
		struct XMLSpecialCharacters
		{
			char Character;
			char* Symbol;
		};
	};
} // End namespace IO
// Updated 5-8-07
namespace IO
{
	const short ZIP_FILE_ENCRYPTED		   = 0x0001;	// Set if the File is encrypted
	const short ZIP_INFO_IN_DATA_DESCRITOR = 0x0008;	// The fields crc-32, compressed Size and uncompressed Size are set to zero in the local header
	struct SZIPFileDataDescriptor
	{
		int CRC32;
		int CompressedSize;
		int UncompressedSize;
	} PACK_STRUCT;
	struct SZIPFileHeader
	{
		int Sig;
		short VersionToExtract;
		short GeneralBitFlag;
		short CompressionMethod;
		short LastModFileTime;
		short LastModFileDate;
		SZIPFileDataDescriptor DataDescriptor;
		short FilenameLength;
		short ExtraFieldLength;
	} PACK_STRUCT;
	struct SZipFileEntry
	{
		String zipFileName;
		String simpleFileName;
		String path;
		int	fileDataPosition;						// position of compressed data in File
		SZIPFileHeader header;
		bool operator <(const SZipFileEntry& Other) const { return simpleFileName < Other.simpleFileName; }
		bool operator ==(const SZipFileEntry& Other) const { return simpleFileName == Other.simpleFileName; }
	};
	class  CZipReader
	{
public:
		CZipReader(IReadFile* File, bool IgnoreCase, bool IgnorePaths);
		 ~CZipReader();
		 IReadFile* OpenFile(const char* Filename);
		IReadFile* OpenFile(int Index);
		unsigned int GetFileCount();
		const SZipFileEntry* GetFileInfo(int Index) const;
		int FindFile(const char* Filename);
	};
	class  CUnZipReader : public CZipReader
	{
public:
		CUnZipReader(IFileSystem* Parent, const char* BaseName, bool IgnoreCase, bool IgnorePaths);
		 IReadFile* OpenFile(const char* Filename);
		int FindFile(const char* Filename);
	
	};
}
// forward-only, Read-only access to a stream of non validated XML data
// Updated 5-1-07
namespace IO
{
	enum XML_TEXT_FORMAT_TYPE	// Enumeration of all supported source text file formats
	{
		XML_TEXT_ASCII,			// ASCII, file without byte order mark, or not a text file
		XML_TEXT_UTF8,			// UTF-8 format
		XML_TEXT_UTF16_BE,		// UTF-16 format, big endian
		XML_TEXT_UTF16_LE,		// UTF-16 format, little endian
		XML_TEXT_UTF32_BE,		// UTF-32 format, big endian
		XML_TEXT_UTF32_LE		// UTF-32 format, little endian
	};
	enum XML_NODE_TYPE			// Enumeration for all xml nodes which are parsed by XMLReader
	{
		XML_NODE_NONE,			// No xml node. This is usually the node if you did not Read anything yet.
		XML_NODE_ELEMENT,		// An xml Element such as <foo>
		XML_NODE_ELEMENT_END,	// End of an xml Element such as </foo>
		XML_NODE_TEXT,			// Text within an xml Element
		XML_NODE_COMMENT,		// An xml comment
		XML_NODE_CDATA,			// An xml cdata section
		XML_NODE_UNKNOWN
	};
	/* Callback class for file Read abstraction. With this, it is possible to make the xml parser Read in Other things  than just files. 
	 * The engine is using this for example to Read xml from compressed .zip files. To make the parser Read in any Other data, derive a 
	 * class from this interface, implement the two methods to Read your data and give a pointer to an instance of your implementation 
	 * when calling CreateXMLReader(), CreateXMLReader16() or CreateXMLReader32() */
	class  IFileReadCallBack
	{
	public:
		 ~IFileReadCallBack() {};
		 int Read(void* buffer, int sizeToRead) = 0;		// Reads an amount of bytes from the file.
		 int GetSize() = 0;								// Returns Size of file in bytes
	};
	// Interface providing easy Read access to a XML file.
	template<class CharType> class IEngineXMLReader
	{
	public:
		 ~IEngineXMLReader() {};
		// Reads forward to the next xml node. 
		 bool Read() = 0;
		// Returns the type of the current XML node.
		 XML_NODE_TYPE GetNodeType() const = 0;
        // Returns attribute count of the current XML node.  This is usually non null if the current node is XML_NODE_ELEMENT, and the Element has attributes.
		 unsigned int GetAttributeCount() const = 0;
		// Returns Name of an attribute. 
		 const CharType* GetAttributeName(unsigned int Index) const = 0;
		// Returns the value of an attribute. 
		 const CharType* GetAttributeValue(unsigned int Index) const = 0;
		// Returns the value of an attribute. 
		 const CharType* GetAttributeValue(const CharType* Name) const = 0;
		// Returns the value of an attribute in a safe way.
		 const CharType* GetAttributeValueSafe(const CharType* Name) const = 0;
		// Returns the value of an attribute as integer. 
		 int GetAttributeValueAsInt(const CharType* Name) const = 0;
		// Returns the value of an attribute as integer. 
		 int GetAttributeValueAsInt(unsigned int Index) const = 0;
		// Returns the value of an attribute as float. 
		 float GetAttributeValueAsFloat(const CharType* Name) const = 0;
		// Returns the value of an attribute as float. 
		 float GetAttributeValueAsFloat(unsigned int Index) const = 0;
		// Returns the Name of the current node. 
		 const CharType* GetNodeName() const = 0;
		// Returns data of the current node. 
		 const CharType* GetNodeData() const = 0;
		// Returns if an Element is an empty Element, like <foo />
		 bool IsEmptyElement() const = 0;
		// Returns format of the source xml file. 
		 XML_TEXT_FORMAT_TYPE GetSourceFormat() const = 0;
		// Returns format of the strings returned by the parser. 
		 XML_TEXT_FORMAT_TYPE GetParserFormat() const = 0;
	};
	/* A UTF-8 or ASCII character xml parser. This means that all character data will be returned in 8 bit ASCII or UTF-8 by this parser. 
	 * The file to Read can be in any format, it will be converted to UTF-8 if it is not in this format. Create an instance of this with CreateXMLReader(); */
	/* A UTF-16 xml parser. This means that all character data will be returned in UTF-16 by this parser.  The file to Read can be in any format, it 
	 * will be converted to UTF-16 if it is not in this format. Create an instance of this with CreateXMLReader16(); */
	/* A UTF-32 xml parser. This means that all character data will be returned in UTF-32 by this parser. The file to Read can be in any format, it will 
	 * be converted to UTF-32 if it is not in this format. Create an instance of this with CreateXMLReader32(); */
	/* Creates an instance of an UFT-8 or ASCII character xml parser. This means that all character data will be returned in 8 bit ASCII or UTF-8.  The file to 
	 * Read can be in any format, it will be converted to UTF8 if it is not in this format. Better not to use this but IFileSystem::CreateXMLReaderUTF8() instead. */
	XMLReader8* CreateXMLReader(const char* FileName);
	// Creates an instance of an UFT-8 or ASCII character xml parser.
	XMLReader8* CreateXMLReader(FILE* file);
	// Creates an instance of an UFT-8 or ASCII character xml parser. 
	XMLReader8* CreateXMLReader(IFileReadCallBack* Callback);
	// Creates an instance of an UFT-16 xml parser. 
	XMLReader16* CreateXMLReader16(const char* FileName);
	// Creates an instance of an UFT-16 xml parser. 
	XMLReader16* CreateXMLReader16(FILE* File);
	// Creates an instance of an UFT-16 xml parser. 
	XMLReader16* CreateXMLReader16(IFileReadCallBack* Callback);
	// Creates an instance of an UFT-32 xml parser. 
	XMLReader32* CreateXMLReader32(const char* FileName);
	// Creates an instance of an UFT-32 xml parser. 
	XMLReader32* CreateXMLReader32(FILE* File);
	// Creates an instance of an UFT-32 xml parser. 
	XMLReader32* CreateXMLReader32(IFileReadCallBack* Callback);
} // End namespace Engine
// The Filelist lists all files in a directory.
// 5-1-07
namespace IO
{
	class  IFileList
	{
	public:
		 ~IFileList() {};
		// Returns the amount of files and directories in the file list.
		 unsigned int GetFileCount() = 0;
		// Gets the name of a file in the list, based on an index.
		// Returns the file name of the file. Returns 0, if an error occured.
		 const char* GetFileName(int Index) = 0;
		// Gets the full name of a file in the list, path included, based on an index.
		// Returns the file name of the file. Returns 0, if an error occured.
		 const char* GetFullFileName(int Index) = 0;
		// Returns of the file is a directory. If an error occurs, the result is undefined.
		 bool IsDirectory(int Index) = 0;
	};
} // End namespace IO
/* The FileSystem manages files and archives and provides access to them. It manages where files are, so that modules which use the the IO 
 * do not need to know where every File is located. A File could be in a .zip-Archive or as File on disk, using the IFileSystem 
 * makes no difference to this.
 * Original 5-1-07, Updated 5-30-07 (GetFileExtension) 6-14-07 (AddFolderFileArchive)
*/
namespace IO
{
	class IReadFile;
	class IWriteFile;
	class IFileList;
	class IXMLWriter;
	class IAttributes;
	class  IFileSystem
	{
	public:
		 ~IFileSystem() {};
		// Opens a File for Read access.
		 IReadFile* CreateAndOpenFile(const char* FileName) = 0;
		// Opens a File for write access.
		 IWriteFile* CreateAndWriteFile(const char* FileName, bool append = false, bool isBinary = true) = 0;
		// Adds an unzipped archive (or base dir/w subdirectories) to the file system, useful for handling data which will be in a zip file
		 bool AddFolderFileArchive(const char* FileName, bool IgnoreCase = true, bool IgnorePaths = true) = 0;
		/* Adds an zip archive to the File system. After calling this, the Irrlicht Engine will search and open files directly from 
		 * this archive too. This is useful for hiding data from the End user, speeding up File access and making it possible to
		 * access for example Quake3 .pk3 files, which are nothing different than .zip files. */
		 bool AddZipFileArchive(const char* FileName, bool IgnoreCase = true, bool IgnorePaths = true) = 0;
		// Adds unzipped archive(or basedirectory with subdirectories..) to File system. Useful for handling data which will be in a zip File
		 bool AddUnZipFileArchive(const char* FileName, bool IgnoreCase = true, bool IgnorePaths = true) = 0;
		
		// Adds an pak archive to the File system.
		 bool AddPakFileArchive(const char* FileName, bool IgnoreCase = true, bool IgnorePaths = true) = 0;
		// Returns the string of the current working directory.
		 const char* GetWorkingDirectory() = 0;
		// Changes the current Working Directory to the overgiven string.
		 bool ChangeWorkingDirectoryTo(const char* NewDirectory) = 0;
		// Converts a relative path to an absolute(unique) path, resolving symbolic links if required
		 String GetAbsolutePath(String& FileName) = 0;
		// Returns the directory a file is located in.
		 String GetFileDir(String &FileName) = 0;
		// Creates a list of files and directories in the current working directory and returns it.
		 IFileList* CreateFileList() = 0;
		// Determinates if a File exists and would be able to be opened.
		 bool ExistFile(const char* FileName) = 0;
		// Creates a XML Reader from a File which returns all parsed strings as wide characters(char*).
		 IXMLReader* CreateXMLReader(const char* FileName) = 0;
		// Creates a XML Reader from a File which returns all parsed strings as wide characters(char*).
		 IXMLReader* CreateXMLReader(IReadFile* File) = 0;
		// Creates a XML Reader from a File which returns all parsed strings as ASCII/UTF-8 characters(char*).
		 IXMLReaderUTF8* CreateXMLReaderUTF8(const char* FileName) = 0;
		// Creates a XML Reader from a File which returns all parsed strings as ASCII/UTF-8 characters(char*).
		 IXMLReaderUTF8* CreateXMLReaderUTF8(IReadFile* File) = 0;
		// Creates a XML Writer from a File.
		 IXMLWriter* CreateXMLWriter(const char* FileName) = 0;
		// Creates a XML Writer from a File.
		 IXMLWriter* CreateXMLWriter(IWriteFile* File) = 0;
	};
} // End namespace IO
// Interface for logging messages, warnings and errors
// Updated 3-17-07
namespace IO
{
	enum LOG_LEVEL
	{
		LOG_INFORMATION = 0,
		LOG_WARNING,	// Default log level, warnings and errors are printed out
		LOG_ERROR,		// Low log level, only errors are printed into the log
		LOG_NONE		// Nothing is printed out to the log
	};
	class  ILogger
	{
	public:
		 ~ILogger() {}
		 LOG_LEVEL GetLogLevel() = 0;														// Returns the current set log level.
		 void SetLogLevel(LOG_LEVEL ll) = 0;
		 void Log(const char* Text, LOG_LEVEL Level = LOG_INFORMATION) = 0;					// Prints out a text into the log
		 void Log(const char* Text, const char* Hint, LOG_LEVEL Level = LOG_INFORMATION) = 0;// Prints out a text into the log
	};
} // End namespace
// Interface providing Read acess to a file.
// Updated 5-1-07
namespace IO
{
	class  IReadFile
	{
	public:
		 ~IReadFile() {};
		// Reads the entire file into the buffer
		 int Read(void* Buffer) = 0;
		// Reads an amount of bytes from the file.
		 int Read(void* Buffer, int SizeToRead) = 0;
		// Changes position in file, returns true if successful.
		 bool Seek(int FinalPos, bool RelativeMovement = false) = 0;
		// Returns Size of file.
		 unsigned int GetSize() = 0;
		// Returns the current position in the file.
		 int GetPos() = 0;
		// Returns name of file.
		 const char* GetFileName() = 0;
	};
	// Internal methods.
	IReadFile* CreateReadFile(const char* FileName);
	IReadFile* CreateLimitReadFile(const char* FileName, IReadFile* AlreadyOpenedFile, int AreaSize);
	IReadFile* CreateMemoryReadFile(void* Memory, int Size, const char* FileName, bool DeleteMemoryWhenDropped);
} // End namespace IO
// Interface providing write acess to a file.
// Updated 5-1-07
namespace IO
{
	class  IWriteFile
	{
	public:
		 ~IWriteFile() {};
		// Reads an amount of bytes from the file.
		 unsigned int Write(const void* Buffer, unsigned int SizeToWrite) = 0;
		// Changes position in file, returns true if successful.
		 bool Seek(int finalPos, bool relativeMovement = false) = 0;
		// Returns the current position in the file.
		 int GetPos() = 0;
		// Returns name of file.
		 const char* GetFileName() = 0;
	};
	// Internal function, please do not use.
	IWriteFile* CreateWriteFile(const char* FileName, bool append, bool isBinary = true);
} // End namespace IO
// Updated 5-1-07
namespace IO
{
} // End namespace IO
/* Interface providing methods for making it easier to write XML files. This XML Writer only writes UTF-16 xml files, because these are parsed 
 * faster than all Other formats by IXMLReader.
 * Updated 5-1-07
 */
namespace IO
{
	class  IXMLWriter
	{
	public:
		 ~IXMLWriter() {};
		// Writes a xml 1.0 header
		 void WriteXMLHeader() = 0;
		// Writes an xml Element with maximal 5 Attributeibutes like "<foo />" 
		 void WriteElement(const char* Name, bool Empty=false,
			const char* Attribute1Name = 0, const char* Attribute1Value = 0,
			const char* Attribute2Name = 0, const char* Attribute2Value = 0,
			const char* Attribute3Name = 0, const char* Attribute3Value = 0,
			const char* Attribute4Name = 0, const char* Attribute4Value = 0,
			const char* Attribute5Name = 0, const char* Attribute5Value = 0) = 0;
		// Writes an xml Element with any number of Attributeibutes
		 void WriteElement(const char* Name, bool Empty, std::vector<String> &Names, std::vector<String> &Values) = 0;
		// Writes a comment into the xml file
		 void WriteComment(const char* Comment) = 0;
		// Writes the closing tag for an Element. Like "</foo>"
		 void WriteClosingTag(const char* Name) = 0;
		// Writes a text into the file. All occurrences of special characters
		 void WriteText(const char* Text) = 0;
		// Writes a line break
		 void WriteLineBreak() = 0;
	};
} // End namespace IO
